{
  "id": "sticler",
  "messages": [
    {
      "id": "msg_1a7a09ea",
      "role": "user",
      "content": "/project-idea we ahve the sticker gmae in the proejct direcroy but if feels bad on design i want that idea imeplemted here but in 3d you run aroudn and buid your weaponsa dn defend you r base and vica versa and you bring toward yourt craft but the project stikcer fosues on the techicnal aspects of the game not the fun aprt teh abse concept is good there, but we want sytsilezd 3d grphics, and 3d bulding your dfenese and 3d aattackign the others defens ei dont my using other engine for the base game and the base game shoudl be local and ageisnt ai aslo with probabyly with premade assetes so in test its good to play agiasnt oruselves with split tiem, wr eneds a beutigul stylized wor d with liek a grid sytem in an air  which si berly visible and player can fly around and palce ther ebloxks liek drawing it in with a given pixel coutn they can wortk with bulky or not, and joing tohter buidlign bluck liek thats as ythey want as they liek to protect the little B \nThe person mentioned in the video who made the grid system \"realistic\" and organic is Oscar Stalberg, the developer behind games like Townscaper and Bad North.\n\nIn technical terms, he solved the problem of stiff, repetitive procedural generation by inventing a unique approach to grid logic and deformation. Here is the technical breakdown of how he made his grid system realistic:\n\n1. The Dual Grid System [03:52]\nTo solve the issue of pieces not fitting together seamlessly (where convex corners looked good but concave corners were sharp), Stalberg utilized a dual grid.\n\nThe Logic: A dual grid is offset by half a cell size. Instead of defining the \"type\" (land or water) for the entire tile, the type is defined for each corner of the tile [05:11].\n\nThe Benefit: This reduced the number of required 3D model variations from 15 down to just 6 distinct tiles while ensuring both convex and concave corners remained perfectly rounded [05:23].\n\n2. Mesh Deformation (Squash and Stretch) [07:13]\nTo move away from a \"blocky\" look, the grid points are \"shaken up\" or randomized.\n\nThe Technical Fix: To prevent the 3D models from breaking apart when the grid is distorted, Stalberg used a set of points on the bounds of the model as handles for deformation [07:25].\n\nVertex Transformation: Every vertex in the model is transformed into a percentage of the total width, height, and depth. When the grid handles move, the vertices move proportionally, allowing the pieces to squash and stretch while remaining connected [07:39].\n\n3. \"Stalberg\u2019s Grid\" (Organic Quadrilateral Grid) [08:08]\nHe invented an algorithm to create an organic-looking grid that is composed entirely of quadrilaterals (quads) rather than triangles, which makes 3D modeling much easier.\n\nThe Process: * Starts with points in a hexagon shape [08:15].\n\nConnects points into triangles and then randomly dissolves edges to turn triangle pairs into quads [08:37].\n\nSubdivides remaining triangles into three quads and then divides every quad into four smaller quads to ensure the entire mesh is quad-based [08:57].\n\nRelaxation Algorithm: He applies a \"relaxation\" step where each point tries to become equally distant from its neighbors, resulting in a smooth, natural layout [09:25].\n\n4. Special Pattern Matching [10:12]\nTo break repetition further, the system checks neighboring tiles for specific patterns. If a pattern is matched (e.g., several land tiles in a specific shape), the system swaps individual tiles for a special piece that spans multiple tiles, adding unique artistic flair to the procedural generation [10:42].\n\nYou can see these techniques in action in his game Townscaper, which is essentially a pure implementation of this organic grid logic. here is how the 3d grid shoudl work with adapting 3d onjehects, foxus on the gmaplay and core workign so i can test the bulding and crafitng of the game, and it wokr and slo the rpfomcae shoudl eb built in also This video by developer Vercidium details how he optimized his custom game engine to reach over 17,000 FPS using several advanced voxel rendering techniques.\n\nHere is the technical analysis of the methods used:\n\n1. Mesh Optimization (Culling and Greed) [01:12]\nHidden Face Culling: The engine skips rendering any voxel faces that are touching another voxel, as they are invisible to the player. This reduced the triangle count from 115 million to 1.2 million [01:23].\n\nGreedy Meshing: Instead of rendering each voxel face as two triangles, the engine combines adjacent faces with the same texture into a single large rectangular face. This further reduces the geometry complexity [01:42].\n\n2. Data Compression & Bit Masking [02:13]\nVertex Compression: Standard vertices used 28 bytes each. Vercidium compressed all vertex data (Position, Normals, and Texture ID) into a single 32-bit integer [03:54].\n\nSmall Ints/Bits for Data: Since the chunks are only 32x32x32, he used 6 bits for each axis (X, Y, Z) instead of 32-bit floats. He reduced the 6 possible normals (cube faces) to just 3 bits [03:41].\n\nBit Masking & Shifting: In the vertex shader, he uses bit masking (&) and bit shifting (>>) to \"unpack\" these 32 bits back into usable spatial and texture data [04:06].\n\n3. Advanced OpenGL Rendering Techniques [05:35]\nGPU Instancing: Instead of a massive unique mesh, the engine uses a \"base model\" of a single quad (4 vertices) and \"instances\" it millions of times using the compressed 32-bit voxel data as the instance list [06:05].\n\nTriangle Strips: By using triangle strips instead of individual triangles, he reduced the vertex count per face from 6 to 4 [05:59].\n\nIndirect Rendering (glMultiDrawElementsIndirect): This is one of the biggest boosts. Instead of the CPU sending thousands of individual draw commands (one for each chunk), it sends one single command to the GPU. All chunk parameters are stored in an \"Indirect Buffer\" [08:34].\n\nShader Storage Buffer Objects (SSBO): Used to store global data like chunk world positions, allowing the shader to calculate where each chunk belongs without needing individual uniforms for every draw call [08:52].\n\n4. Back-Face Culling at Chunk Level [10:05]\nTo prevent the vertex shader from even processing triangles facing away from the player, he splits each chunk's mesh into six separate meshes (one for each direction).\n\nThe engine only sends the meshes to the GPU that are facing toward the player's camera, cutting the workload significantly before it even hits the vertex shader [10:34].\n\nBy combining these techniques\u2014specifically Greedy Meshing in two directions and Indirect Rendering\u2014the engine's performance jumped from 50 FPS to over 17,000 FPS [11:29]. we shoudl optimze for 20000+ fps in the mvp in full hd ",
      "images": [],
      "timestamp": "2026-01-31T20:43:05.327656"
    }
  ],
  "created_at": "2026-01-31T20:43:05.335607",
  "project": "sticler",
  "updated_at": "2026-01-31T20:43:05.336262"
}